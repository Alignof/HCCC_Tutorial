# ローカル変数
本セクションでは，遂にローカル変数を扱えるようになります．  
ローカル変数は「スタック領域」に確保します．  
  
## ローカル変数を確保  
ではスタック領域をどうやって確保するかというと単純で，スタックポインタを欲しい分だけ減らせば良いのです．  
スタックポインタを予め減らしておけば，その領域をローカル変数のために使うことができます．
割り当てた領域はコンパイラ，もといあなたが自分で決めて値を出したり入れたりします．
このスタックポインタの増減はprologueとepilogueで行います．  

以下はセクション2でお見せしたものに変数の確保を足したものです．
```asm
.intel_syntax noprefix ; #1
.globl main ; #2

main: ; #3
    ; #4: prologue
    push rbp
    mov rbp, rsp
    sub rsp, 0x8 ; allocate stack (sizeof(int) * 2)

    mov rax, 0

    ; #5: epilogue
    pop rbp
    ret
```

rspから8だけ引いたので今8byte分確保されました．

なお，このとき引き算する量は，**8の倍数にしておいてください**．

## ローカル変数へレジスタの値を代入
rbpから12byteのところにある4byteのデータにeaxの値を入れるアセンブリです．
```
mov DWORD PTR [rbp - 12], eax 
```

この DWORD PTR というのは「4 byte 単位で操作する」という意味です．

| 操作幅 | 書き方 |
|-------|--------|
| 1 byte | BYTE PTR |
| 2 byte | WORD PTR |
| 4 byte | DWORD PTR |
| 8 byte | QWORD PTR |

## ローカル変数の値をレジスタに代入
rbpから12byteのところにある4byteのデータをeaxに入れるアセンブリです．
```
mov eax, DWORD PTR [rbp - 12] 
```

## ローカル変数のアドレスをレジスタに代入
scanfなどでアドレスを入れる必要があるときは以下のようにします．  
rbpから4byteのところにあるアドレスをraxに入れるアセンブリです．  
```
lea rax, [rbp - 0x4] 
```

今回は，アドレスを得ているので，それを入れる先は 64 ビットの rax にしてやる必要がありますし，PTR 幅も書きません．

なお，余談ですが，この lea という命令はローカル変数を操作する以外にも，いろんな使いかたをすることができます．たとえば，rdi を 4 倍してそれに 3 を足した値を rax に入れるのに，

```
lea rax, [4*rdi + 3]
```

と書くことができます．便利ですね．

# 次のセクション
[section6: 関数呼び出し](/sections/section6_CallFunction.md)
