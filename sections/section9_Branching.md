# 条件分岐

ラベルを使うと，`jmp` ができるのでした．

しかし，条件分岐のために必要なのは，「条件に基づいたジャンプ」です．それを実現するにはどうすればいいのでしょうか．

## ジャンプによる条件分岐

C 言語では，if や while といった制御構文を用いることによって，条件に基づいたジャンプができるのでした．

「a が b よりも大きいならば」という条件を C 言語で表すには，

- 「a が b よりも大きい」→ `a > b`
- 「ならば」→ `if ()`

という組み合わせで表します．

アセンブリでは，ここの考え方が少し違い，「eax が ecx よりも大きいならばジャンプ」を次のように分割します．

- 「eax が ecx ...」→ `cmp eax, ecx`
- 「...よりも大きいならばジャンプ」 → `jg ラベル名`

つまり，

1. cmp 命令に二つの値を与え，その二つの値の間の関係性を覚えておく
2. Jcc 命令を使い，「覚えておいた関係性を見て，条件を満たしているか判断」し，それに応じてジャンプ

という，一見奇妙な切り分け方をするのです．

ここで，「Jcc 命令」と呼びましたが，その実態は「～ならばジャンプ」をするための多数[^1]の命令の総称です．とりあえず，よく使う以下の 6 種を覚えておくとよいでしょう．

| cc | Jcc | 意味 | 同じ意味の別名 |
| e | `je` | 「...と等しいならば」 | z |
| ne | `jne` | 「...と等しくないならば」 | nz |
| l | `jl` | 「...未満ならば」 | nge |
| le | `jle` | 「...以下ならば」 | ng |
| g | `jg` | 「...未満ならば」 | nle |
| ge | `jge` | 「...以下ならば」 | nl |

[^1]: o, no; b=c=nae, nb=nc=ae; e=z, ne=nz; be=na, nbe=a; s, ns; p=pe, np=po; l=nge, nl=ge; le=ng, g=nle と，16 種の命令に 30 種類の名前が当たっています． 

## ジャンプなしの条件分岐

このように，「ラベルを置いて，条件に応じてジャンプしたりしなかったりする」というのが条件分岐の基本パターンです．しかしながら，

そのために使うのが，SETcc です．この cc というのは先ほどの Jcc と同様の意味で，SETcc は，「cc で表される条件が成り立ったら 1 を，そうでなかったら 0 を，目的の 8 ビットの場所に代入する」という命令です．

なお，SETcc の結果は 8 ビットの場所にしか代入できず，残りの上位 56 ビットは演算前の状態が残ってしまいます．それを解決するのが，「8 ビットから読んで，上位ビットを 0 で埋めて 32 ビットにして書き込む」という役割を持つ `movzx` 命令です．

つまり，

```
cmp eax, edx
sete al
movzx eax, al
```

とすることで，C 言語でいう `eax = (eax == edx);` が書けるようになります． 

もう一つ，CMOVcc という命令も知っておくとアセンブリ手書きがラクになるかもしれません．これは，「条件が成立するときだけ，レジスタへと mov してくれる」という命令です．

```
cmp edi, esi
cmovne eax, DWORD PTR [rbp-20]
```

と書くと，「edi と esi が等しくないときだけ，rbp-20 の位置にあるローカル変数の中身を eax に書き込む」というのが実現できます．

# おめでとう！
[これでアセンブリはばっちり！さあ君も人間Cコンパイラだ！](https://hccc-in-seccamp.vercel.app/)