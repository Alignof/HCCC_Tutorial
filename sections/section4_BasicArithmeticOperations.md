# 四則演算・レジスタのサイズと符号

## 足し算・引き算・掛け算

このチュートリアルではintel syntaxを採用するので，足し算・引き算・掛け算は，次のように行います．

```
.intel_syntax noprefix

add rax, 20 ; rax を 20 増やす
sub rbx, rax ; C でいう rbx -= rax
imul rcx, 0x14 ; rcx を 0x14 倍，つまり 20 倍にする 
```

特に難しいことはありませんね．

しかしながら，割り算は結構面倒で，先に「レジスタのサイズと符号」を説明しなくてはいけません．

## レジスタのサイズと符号

ついに，レジスタに関して真面目に解説するときがきました．

前々回，「rbpは*ベースレジスタ*と呼ばれるオフセットの基準となるアドレスが記憶されたレジスタです．」と説明しました．ここから分かるように，レジスタというのは，CPUが値を一時的に覚えておくために使う記憶装置のことです．

四則演算などの計算をする上で，自由に使える以下の 9 本のレジスタをご紹介しましょう．

```
rax
rdi
rsi
rdx
rcx
r8
r9
r10
r11
```

これらは全て 64 ビットレジスタです．つまり，これらは 64 ビットの変数として扱える，ということです．

ところで，これらのレジスタには，「下位 32 ビットを表す別名」があります．

| 64 ビット | 下位 32 ビット |
|-----------|--------------|
| rax | eax | 
| rdi | edi | 
| rsi | esi | 
| rdx | edx | 
| rcx | ecx | 
| r8  | r8d | 
| r9  | r9d | 
| r10 | r10d | 
| r11 | r11d | 

つまり，たとえば rdx に値を入れたら，その下位 32 ビットを edx というレジスタとして読み出すことができる，ということです．

**ただし**，下位 32 ビットの名前へと書き込みが発生した場合，**そのレジスタの上位 32 ビットは強制的に 0 になる**という仕様に注意して下さい．


## 割り算

先ほども述べた通り，割り算は若干面倒です．

というのも，割り算には商と余りがありますし，

「64 ビットの数を 32 ビットの数で割り，32 ビットの商と 32 ビットの余りを得る」

「128 ビットの数を 64 ビットの数で割り，64 ビットの商と 64 ビットの余りを得る」


<!-- 四則演算に関しては閲覧を許可されている外部の資料を見て対応する命令を書けば問題無いと思います．  
外部資料：[X86アセンブラ - Wikibooks](https://ja.wikibooks.org/wiki/X86%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%A9) --> 

# 次のセクション
[section5: ローカル変数](/sections/section5_LocalVariable.md)
