# 四則演算・レジスタのサイズ

## 足し算・引き算・掛け算

このチュートリアルではintel syntaxを採用するので，足し算・引き算・掛け算は，次のように行います．

```
.intel_syntax noprefix

add rax, 20 ; rax を 20 増やす
sub rbx, rax ; C でいう rbx -= rax
imul rcx, 0x14 ; rcx を 0x14 倍，つまり 20 倍にする 
```

特に難しいことはありませんね．

しかしながら，割り算は結構面倒で，先に「レジスタのサイズ」を説明しなくてはいけません．

## レジスタのサイズ

ついに，レジスタに関して真面目に解説するときがきました．

前々回，「rbpは*ベースレジスタ*と呼ばれるオフセットの基準となるアドレスが記憶されたレジスタです．」と説明しました．ここから分かるように，レジスタというのは，CPUが値を一時的に覚えておくために使う記憶装置のことです．

四則演算などの計算をする上で，自由に使える以下の 9 本のレジスタをご紹介しましょう．

```
rax
rdi
rsi
rdx
rcx
r8
r9
r10
r11
```

これらは全て 64 ビットレジスタです．つまり，これらは 64 ビットの変数として扱える，ということです．

ところで，これらのレジスタには，「下位 32 ビットを表す別名」があります．

| 64 ビット | 下位 32 ビット |
|-----------|--------------|
| rax | eax | 
| rdi | edi | 
| rsi | esi | 
| rdx | edx | 
| rcx | ecx | 
| r8  | r8d | 
| r9  | r9d | 
| r10 | r10d | 
| r11 | r11d | 

つまり，たとえば rdx に値を入れたら，その下位 32 ビットを edx というレジスタとして読み出すことができる，ということです．

**ただし**，下位 32 ビットの名前へと書き込みが発生した場合，**そのレジスタの上位 32 ビットは強制的に 0 になる**という仕様に注意して下さい．


## 割り算

先ほども述べた通り，割り算は若干面倒です．

というのも，割り算には商と余りがあるからです．

これにうまく対処するために，割り算をする命令では rax と rdx レジスタが特殊扱いされています．

割り算のときの使う命令は `idiv` 命令です．これは，直後にレジスタ名を一つ書くと，次のような挙動をします．

|    | レジスタが 64 ビット（例: `idiv rsi`） | レジスタが 32 ビット（例: `idiv esi`） |
|----|---------------------|--------------------|
| 割られる数 | 上位 64 ビットを `rdx`，下位 64 ビットを `rax` とした 128 ビットの数 | 上位 32 ビットを `edx`，下位 32 ビットを `eax` とした 64 ビットの数 |
| 割る数 | `rsi` | `esi` |
| 商の格納先 | `rax` | `eax` |
| 余りの格納先 | `rdx` | `edx` |


つまり，

- 「64 ビットの数を 32 ビットの数で割り，32 ビットの商と 32 ビットの余りを得る」

- 「128 ビットの数を 64 ビットの数で割り，64 ビットの商と 64 ビットの余りを得る」

の両方が `idiv` という命令でできる，ということになるわけです．


# 次のセクション
[section5: ローカル変数](/sections/section5_LocalVariable.md)
