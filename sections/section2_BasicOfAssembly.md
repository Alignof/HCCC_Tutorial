# アセンブリの基礎
アセンブリを読んだことはあっても書いたことは無いという人が大半なんじゃないでしょうか．  
このセクションではアセンブリの雛形を書くことができるところまでを解説しようと思います．  

## 最もシンプルなアセンブリ 
最もシンプルなC言語のコードは以下のようなものだと思います．
```c
int main(void) {
    return 0;
}
```

これに対応する簡単なアセンブリは以下です．
```asm
.intel_syntax noprefix ; #1
.globl main ; #2

main: ; #3
    ; #4: prologue
    push rbp
    mov rbp, rsp

    mov rax, 0

    #5: epilogue
    pop rbp
    ret
```

まず`#1`の部分は記法を指定しています．    
これは好みの問題ですが，このチュートリアルではintel syntaxを採用するのでこのディレクティブを加えています．    
ちなみに今回使っているGNU asではデフォルトがAT&T記法なのでAT&T記法を使いたい場合は何も書かなくてOKです．    

次に`#2`の部分を見てみると`.globl main`とあります．これはこの下にある`main:`を指しておりmainというラベルの位置が
このプログラムのエントリポイントであることを示しています．  

`#3`はみなさんご存知main関数を示しています．  
この位置から順に処理が始まっていきます．  
最後に`:`（コロン）が付いていますが，これがラベルというもので位置の目印として使います．  
この位置を使って関数に飛んだりループのために戻ったりデータを取ってきたりするのです．  
  
`#4`からの2行がプロローグと呼ばれるものです．  
rbpをスタックに退避してrspの値をrbpに代入しています．  

ここで大事なのはレジスタの意味です．  
rbpは*ベースレジスタ*と呼ばれるオフセットの基準となるアドレスが記憶されたレジスタです．
前の関数の基準となるアドレスを保存して新たにスタックの頂点を基準にしたわけです．
ここでスタックポインタをずらして変数のための領域を確保することもありますがそれはあとの話．

`#5`からの2行はエピローグと呼ばれるものです．  
これはよく見れば分かりますが，プロローグと全く逆のことをしています．  
pushで退避していたベースレジスタの値をpopしたスタックから戻します．  
そして元の関数に戻る`ret`命令を使ってmain関数からもとの場所に戻るのです．  
  
prologueとepilogueに挟まれたmov命令は何なのか？  
それは次のセクションでお話します．  

## まとめ
- intel記法を使うには`.intel_syntax noprefix`
- エントリポイントを指定するには`.globl`
- 関数はprologueで始まりepilogueで終わる

# 次のセクション
[section3: exitcodeを返す](/sections/section3_ReturnExitCode.md)

