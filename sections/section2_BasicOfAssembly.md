# アセンブリの基礎
アセンブリを読んだことはあっても書いたことは無いという人が大半なんじゃないでしょうか．

「そもそもアセンブリを読むのも今日が初めて」という人もいることでしょう．

このセクションでは，アセンブリの雛形を書くことができるようになるところまでを解説しようと思います．  

## 最もシンプルなアセンブリ 
最もシンプルなC言語のコードは以下のようなものだと思います．
```c
int main(void) {
    return 0;
}
```

これに対応する簡単なアセンブリは以下です．
```asm
.intel_syntax noprefix ; #1
.globl main ; #2

main: ; #3
    ; #4: prologue
    push rbp
    mov rbp, rsp

    mov rax, 0

    ; #5: epilogue
    pop rbp
    ret
```

まず`#1`の部分は記法をintel記法に指定しています．    
これは好みの問題ですが，このチュートリアルではintel syntaxを採用するのでこのディレクティブを加えています．    
ちなみに今回使っているGNU asではデフォルトがAT&T記法なのでAT&T記法を使いたい場合は何も書かなくてOKです．    

次に`#2`の部分を見てみると`.globl main`とあります．`main`はこの下にある`main:`というラベルを指しており，
これを外部から参照できるようにする意味があります．`main`はプログラムのエントリポイントであるので外部から参照して
飛べるようにする必要があるのです．  

`#3`はみなさんご存知main関数を示しています．  
この位置から順に処理が始まっていきます．  
最後に`:`（コロン）が付いていますが，これが「ラベル」というもので位置の目印として使います．  
この位置を使って関数に飛んだりループのために戻ったりデータを取ってきたりするのです．  
  
`#4`からの2行がプロローグと呼ばれるものです．  
rbpをスタックに退避してrspの値をrbpに代入しています．  

ここで大事なのはレジスタの意味です．  
rbpは*ベースレジスタ*と呼ばれるオフセットの基準となるアドレスが記憶されたレジスタです．
前の関数の基準となるアドレスを保存して新たにスタックの頂点を基準にしたわけです．
ここでスタックポインタをずらして変数のための領域を確保することもありますが，それはあとの話．

`#5`からの2行はエピローグと呼ばれるものです．  
これはよく見れば分かりますが，プロローグと全く逆のことをしています．  
pushで退避していたベースレジスタの値をpopしてスタックから戻します．  
そして元の関数に戻る`ret`命令を使ってmain関数からもとの場所に戻るのです．  
  
prologueとepilogueに挟まれたmov命令は何なのか？  
それは次のセクションでお話します．  

## まとめ
- intel記法を使うには`.intel_syntax noprefix`
- `.globl`を使って外部から参照できるシンボルを指定する
- 関数はprologueで始まりepilogueで終わる

# 次のセクション
[section3: exitcodeを返す](/sections/section3_ReturnExitCode.md)

